---
title: "London Cycle Hires and Weather"
output: html_document
---
```{r, echo=F, warning=F, message=F}
library(ggplot2)
library(reshape2)
library(dplyr)
library(lubridate)
```

```{r, echo=F}
weather <- read.csv('weather.csv')
names(weather) <- c('date', 't.max', 't', 't.min', 'dew.max', 'dew', 'dew.min',
                    'hum.max', 'hum', 'hum.min', 'pres.max', 'pres', 
                    'pres.min', 'vis.max', 'vis', 'vis.min', 'wind.max',
                    'wind', 'gust', 'precip.mm', 'cloud', 'events', 'wind.dir')

weather$date <- as.Date(weather$date)

# The events are Fog, Rain, Snow, and Thunderstorm. Only rain and fog have 
# enough days to be worth looking at (even fog is marginal, at 36).
weather$rain <- grepl('Rain', weather$events)
weather$fog <- grepl('Fog', weather$events)

read.bikes <- function (fname) {
  bikes <- read.csv(fname)

  # Remove columns we won't be looking at. id/lat/long are constant within each
  # file. The others are constant over the whole dataset.
  bikes$id <- NULL
  bikes$lat <- NULL
  bikes$long <- NULL
  bikes$installed <- NULL
  bikes$locked <- NULL
  bikes$temporary <- NULL

  # Rename and restructure
  names(bikes) <- c('updated', 'name', 'num.bikes', 'num.spaces')
  bikes$updated <- as.POSIXct(strptime(bikes$updated, "%Y-%m-%dT%H:%M:%S%z"))
  
  # Add columns derived from existing ones. `time` is an integer for 
  # simplicity. I'm not doing any actual temporal manipulations with it.
  bikes$updated.time <- with(bikes, 100 * hour(updated) + minute(updated))
  bikes$updated.date <- as.Date(bikes$updated)
  bikes$num.docks <- with(bikes, num.bikes+num.spaces)
  bikes$weekday <- wday(bikes$updated, label=T)

  # Add columns for prev and diff between updates. I feel like there should be
  # a better way to do this, but I haven't found it. (Time series don't seem to
  # work very well.) Only add ones I actually use.
  bikes$prev.updated <- c(as.POSIXct(NA), head(bikes$updated, -1))
  bikes$prev.updated.time <- 
    with(bikes, 100 * hour(prev.updated) + minute(prev.updated))
  bikes$prev.updated.date <- as.Date(bikes$prev.updated)
  bikes$prev.num.bikes <- c(NA, head(bikes$num.bikes, -1))
  bikes$prev.num.docks <- c(NA, head(bikes$num.docks, -1))

  bikes$d.updated <- with(bikes, as.numeric(updated - prev.updated))
  bikes$d.num.bikes <- with(bikes, num.bikes - prev.num.bikes)
  
  return(bikes)
}

bikes <- rbind(read.bikes('bikes-sp.csv'),
               read.bikes('bikes-hh.csv'),
               read.bikes('bikes-bp.csv'),
               read.bikes('bikes-es.csv'))

bikes <- merge(x=bikes, y=weather, by.x='updated.date', by.y='date')
```

I'm interested in investigating the usage of London's cycle hire scheme, and in particular how it's affected by the weather.

What does the weather look like?
```{r}
ggplot(melt(weather, id.vars='date', measure.vars=c('t.min','t','t.max')),
       aes(x=variable, y=value)) + 
  geom_boxplot()
ggplot(weather, aes(y=precip.mm, x=rain)) + geom_boxplot()
```

If `rain` is false, `precip.mm` is almost always 0, but occasionally not. And if `rain` is true, `precip.mm` is still often 0.

Graph of the length of time spent with a given number of active docks:
```{r, warning=F}
ggplot(bikes, aes(x=prev.num.docks, y=d.updated/60/24)) +
  geom_histogram(stat='identity') +
  facet_wrap(~name)
```

We see that every station was reporting less than a full complement of docks more than half the time; but only Southampton Place was completely out of service for any significant period.

What does the correlation look like between #bikes at each tick?

```{r, warning=F}
ggplot(bikes, aes(x=num.bikes, y=prev.num.bikes, color=name)) + 
  geom_jitter(alpha=0.05)

cor.test(bikes$num.bikes, bikes$prev.num.bikes)
```

This is very strong correlation, with the most common outcome being that the number of bikes hasn't changed.

Are more journeys taken on non-rainy days?

```{r, warning=F}
ggplot(group_by(bikes, rain) %>% mutate(count=1/length(rain)),
       aes(x=d.num.bikes, y=count)) + 
  geom_bar(stat='identity') +
  scale_x_discrete() +
  facet_wrap(~rain)
```

Looks like it. Slightly over 70% of observations have no bikes added or removed on rainy days, slightly under 70% on clear days. Confirming this numerically (taking the absolute value):

```{r}
summary(abs(bikes$d.num.bikes[bikes$rain]))
summary(abs(bikes$d.num.bikes[!bikes$rain]))
```

The mean is almost 25% higher on clear days than rainy days. What about fog?

```{r, warning=F}
ggplot(group_by(bikes, fog) %>% mutate(count=1/length(fog)),
       aes(x=d.num.bikes, y=count)) + 
  geom_bar(stat='identity') +
  scale_x_discrete() +
  facet_wrap(~fog)

summary(abs(bikes$d.num.bikes[bikes$fog]))
summary(abs(bikes$d.num.bikes[!bikes$fog]))
```

Fog makes approximately no difference.

What about journeys on different weekdays?

```{r, warning=F}
ggplot(bikes, aes(x=weekday, y=abs(d.num.bikes))) + geom_bar(stat='identity')
ggplot(bikes, aes(x=weekday, y=num.bikes)) + geom_boxplot()
```

Fewer journeys are taken on weekends. The median number of bikes available doesn't change much throughout the week, but the distribution does. Looking closer at that:

```{r, warning=F}
ggplot(bikes, aes(x=num.bikes/num.docks)) + 
  geom_density() + 
  facet_wrap(~weekday)
```

Saturday and Sunday have noticeably different shapes to the others. They have a single peak, while weekdays are somewhat bimodal, with a small peak where the station is full (probably when people are arriving at work). Since the stations have different numbers of docks, I did a graph of fullness rather than of number of bikes.

(The density plot doesn't show peaks exactly at 0 and 1 because of how the window works, but histograms of num.bikes and num.spaces show that that's where they are. It would be difficult to use a histogram for this graph because there's no sensbile binwidth.)

I also want to look at the number of bikes available at specific times. Since I only have snapshots, I'm going to take the first observation after that time on any given day. Here's a function that lets me do that:

```{r}
at.time <- function(time) {
  # prev.updated.time < time <= updated.time is the obvious test. But it fails
  # around day boundaries, so we also check whether the date changed.
  # Additionally, ignore results where d.updated.time is too big, because those
  # may not be accurate.
  with(bikes, (prev.updated.time < time | prev.updated.date < updated.date) &
              time <= updated.time &
              d.updated <= 20)
}
```

So, number of slots available at 0930, when I'm trying to arrive at work:

```{r}
ggplot(bikes[at.time(0930),], aes(x=num.spaces)) + 
  geom_histogram(binwidth=1) +
  facet_wrap(~name)
```

What's that in terms of frequency?

```{r}
ggplot(bikes[at.time(0930),] %>% 
         group_by(name) %>% 
         mutate(count=1/length(name)),
       aes(x=num.spaces, y=count)) +
  geom_bar(stat='identity',binwidth=1) +
  facet_wrap(~name)
```

And now at 0940, in case I'm running late:

```{r}
ggplot(bikes[at.time(0940),] %>% 
         group_by(name) %>% 
         mutate(count=1/length(name)),
       aes(x=num.spaces, y=count)) +
  geom_bar(stat='identity',binwidth=1) +
  facet_wrap(~name)
```

The 0s are all a little higher, but there's not much in it.
